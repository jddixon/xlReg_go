xlReg_go/TODO

2014-10-16
    * change NewMemberMaker() to take node as an argument, with a
        consequent requirement that the nodeID is set

    * GOAL: MemberInfo should be merged with or become Peer
    * Then cluster members should be added to Node.peers[]

    * Calls to MkdirAll(lfs) should be replaced by 
        xf.CheckLFS(lfs, perm)
        - this requires a change to the CheckLFS() interface

    * URGENT: reg.ContainsID() is failing (eg eph_server_test.go)

2014-10-15
    * FIX: epCount at end of clusterMember serialization is wrong
    * in the definition of ClusterMember struct (line 26 or so) it 
        claims that the EPCount is potentially different from the 
        count of endpoints passed to xn.New(), but this is nowhere 
        enforced

    * FIX: endPoint ports in clusterMember serialization are wrong
        - the clusterMember's ports are correct but the port 
            numbers in MemberInfo are wrong, because port numbers
            are reported to the registry before they have been bound
            * fix is to initialize clusterMember xlNode *before* 
                the call to xlReg
                - this can only be done after the MemberAndOK()
                    call, which picks up the nodeID from the registry
                    * called by AdminMember, SoloMember, and UserMember

    * FIX: clusterMember serialization: indentation of memberInfo{} 
        within members{} is wrong

    * to reduce confusion, rename MemberNode MemberMaker                * DONE
    * verify that references to cluster member endPoints use
        GetEndPoint(n) or GetAcceptor(n)

    * SoloMember should NOT persist a ClusterMember and in fact
        it just calls PersistNode()
    * AdminMember is completely ephemeral; it does not persist anything
    * UserMember also doesn't persist anything; its mission is to 
        collect MemberInfo.  Callers can persist the information, but
        the endPoints will necessarily be WRONG, as discussed above.

2014-10-14
    * memberNode.go: 
        - split MemberNode into container (MemberMaker) and the bits
            that get serialized (ClusterMember + what?)
            * if what? is not an empty set, add its bits to 
                ClusterMember
        - notice overlap with existing function PersistNode()
        - and PersistClusterMember(), which is nowhere used             * FALSE
    * xlReg_go version then becomes v1.3 or 2.0

2014-10-07
    * FIX: README.md currently is more or less a duplicate of           * DONE
        ghpDoc/index.md (drops last para), but this is silly, because   * DONE
        the text references other files in ghpDoc/ using relative       * DONE
        paths.  Fix by simply dropping the link(s).                     * DONE

2014-10-07 (-07-25, edited)
    * install current version 1.2.0 on EC2/portland), port 56789              
    * confirm 'go test' succeeds on EC2                                 * DONE
    * regenerate /var/app/xlReg/.xlattice and regCred.dat               * DONE
    * regenerate xlreg_* documentation, which includes regCred.dat      * DONE
    * need to automatically edit private IP address, 192.168.240.4
        in this case, to the public IP address, 54.187.133.62
        - sed
    * need test here which runs against portland:56789

2014-10-06
    * /var/app/xlReg/regCred.dat is 0640, should be 0644                * FIXED
    * replace xi.IDMap with HAMT                                        * DONE
        - this means we need a way to specify w and t                   * DONE
            * default to 6                                              * DONE

2014-10-05
    * change DEFAULT_PORT to 56789                                      * DONE
        - if testing defaults to TEST_DEFAULT_PORT, 45678               * DONE
        - go build && go install                                        * DONE
    * add port 56789 to EC2 security groups in the four regions         * DONE

2014-09-16
    * MemberNode.{endPoints,lfs,name} appear to be wholly redundant;
        consider dropping them
    * MemberNode.{c,s}kPriv are redundant given Node.Get{C,S}KPriv()

2014-09-13
    * REVIEW: ClientNode.clientID renamed ClientID, other fields
        not similarly exposed
        - need to at least adjust version date
    * REVIEW: ClientNode fields size, epCount were int, now uint
    * REVIEW: ClusterMember fields SelfIndex, ClusterSize, 
        EpCount were uint32, now uint
    * REVIEW: protocol ClusterSize and EndPointCount are uint32,
        whereas struct fields are uint

2014-09-12
    * EphServer.GetAcceptor() needs to be tested
        - NO, should be dropped; this is just Server.GetEndPoint(0)

    * reg_cluster_test.go is incomplete; when paxos_go/pktComms/
        keep_alive_test.go is working, backport relevant bits
        - NO, eph_server_test.go is the model to follow

2014-07-03
    BUT TEST SUCCEEDS ON PORTLAND:
    * FIX: cluster_member_test.go line 62 gets strconv.NumError
        (Func:"ParseInt", Num:"4592296101443653904", presumably
        because EC2 instances are in some sense 32-bit, whereas
        software developed on 64-bit machines

    * need -d/--runDetached switch to make server run detached
    * to start from rc.local need -u/--user option
    * RESOLVE: regCred.dat should include publicly accessible IP
        address, but on EC2 cloud has to use its private (10/8 or 
        192.178.*/24) address to get address to bind
        - if 127.0.0.1 is used, clients must be on same host

2014-05-14
    * review whether reg_node.go actually needs xlattice_go/msg
    * website needs new reg_cred before this is deployed

2014-02-24
    * write testData_test.go exercising data in test_dir as model for
        xlreg_*
        - 001 regCred tests                                             * DONE
        - 002 hello/reply tests                                         * DONE
            * do hello/reply with stockton
        - 003 client/ok tests
        - 004 create/reply
        - 005 join/reply
        - 006 get/members
        - 007 bye/ack

2014-02-20
    * need to step version number at each branch merge
    * investigate: msg_handlers.go L 169: "NO LONGER MAKES ANY SENSE"
    * also determine why xlReg continued to load on Stockton 
        despite having no /var/app/xlReg

2014-02-03 (2013-10-09, edited)
    * ClientMsg is
        - EITHER token with digSig but without clientID
        - OR clientID plus salt plus digSig

2013-12-06
    * NewRegistry must populate indexes if clusters supplied

2013-12-05
    * UserClient.Run() may return error, especially EOF, in which case
        we need to try again; using code needs to be fixed

2013-11-22
    * modify client_node.go to use SetupSessionKey()
    * insofar as possible, ClientNode.SessionSetup() should
        migrate to AesCnxHandler.InitSessionSetup()
    * insofar as possible, InHandler.handleHello() should
        migrate to AesCnxHandler.ReceiverSessionSetup()
    * consider migrating to another package
        - aes_cnx.go
        - msg.ServerDecodeHello()
        - msg.ServerEncodeHelloReply()
    * the other package could be protocol/aescnx/, but the code must
        be stable and usable externally
    * cnx initializer / receiver distinction must be made very clear
        and the code (re)structured accordingly
    * XXX the problem is the protobuf protocol, which will vary from
        application to application
        - need at least proto.Unmarshal and proto.Marshal functions
        - don't know cost of using interface{} instead of eg *XLRegMsg
        - alternative is to build a code generator; need not be in Go
        - it's acceptable in the short term to simply copy and edit
            the code in xlattice_go/reg
        - tentively
            xlattice_go/protocol/AesCnxHandlerGen -s NAME -l LONGNAME
            where NAME/LONGNAME is that of the protocol

2013-11-18
    * this introduced a bug not caught here; need to modify tests
        to catch it

2013-11-05
    * Registry is logging EOFs on all client connections; this
        should be dropped

2013-11-04
    * xlReg should log all interactions
        - cluster joins
    * logging should be in separate goroutines and should include at
        least the IP address and port number at the far end of the
        connection (to gather enough information for blacklisting
        where appropriate)
    * xlReg is dying at seemingly random intervals; need to log errors
        where possible
        - "fatal I/O error accept tcp ...: use of closed network
            connection, shutting down the server"
        - ignoring this in tests results in infinite loop
            * it appears to be the acceptor (the listening socket)
                which is closed, so ignoring it is impossible
            * we are in fact using the close() to shut down the server,
                so it makes no sense at all to ignore this particular
                error.
            * so need to determine which end of the connection is
                closed and respond accordingly (far end: who cares?
                this end: we are done)

2013-11-02
    * connections to xlReg are being left open; the server should
        close

2013-10-31
    * need to properly implement 10-02 Registry-related items
    * when ParseRegistry is available, code must be available which
        rebuilds volatile data structures, including ClustersByName
        and ClustersByID
        - in particular, the registry ID and all cluster IDs must be
            in the registry Bloom filter

2013-10-28
    * (from 10-17) xlReg starting for the first time should
        - writes regCred to the log

2013-10-25
    * drop options.Ephemeral, which is implied by empty backing
        file name ?
2013-10-18
    * Whatever is using BadVersion should be using the DecimalVersion
        type
        - This is in reg/in_handler.go init() and references VERSION in
            ../const.go.

2013-10-17
    * determine what LFS is being used and whether the node is
        being serialized to LFS/.xlattice/node.config

2013-10-17
    * NewSoloClient needs mode parameter which is ORed into default
        0600 on LFS/.lattice/node.config

    * FIX: InHandler.doCreateMsg() treatment of existing clusters
        doesn't make any sense

    REGISTRY SERVER
    * (longer run) verify that xlReg can be configured to listen on
        either ALL IP addresses or on more than one IP address,
        such as {192.168.152.10.44444, 192.168.136.10.44444}
    * add RegCred message, which of course can't be used without
        knowing the registry's comms public key

    * ephemeral admin client unique ID should be itself ephemeral

    UTILITIES
    * xlClusterReg -e -s K -o FILE CLUSTER_NAME -p PERM
        where K is cluster size, FILE defaults to ./reg.cred
    * xlRegCred -o FILE IP_ADDR:PORT
        where FILE defaults to ./cluster.cred, PERM to 0640
        utility which retrieves regCred, displays and/or
        writes to LFS/.xlattice/reg.cred perm 0444

2013-10-13
    * ClientNode must be able to read config from LFS
    * CHANGE Client/ClientOK to expect either
        - token without name but with digSig OR
        - clientID plus digSig
    *ClientNode Node is created after keys are created and ID is known

2013-10-12
    * need clear decision: does UserClient get clusterName?
    * use BloomSHA to handle registry ID map?  about 300 SLOC
        in Java (as implemented in xlattice_j)

2013-10-11
    * msg_handlers doClientMsg about line 70 sets all generated
        IDs to 32 bytes (SHA3)
    * doClientMsg assigns an ID if nil but just uses the SHA3
        of ckPriv and skPriv; need to add some randomness!
    * server must guarantee uniqueness of all IDs, including
        - unique clientID (both user and admin)
        - unique clusterID
    * so registry must have a map of all IDs used

2013-10-10
    * msg_handlers.go doClientMsg: change to either
        - accept ID, which must be known, plus digsig
        - or to accept token without ID plus digsig
            * in this case it generates a new and unique ID
        - old tests must continue to run at least until new
            code is stable

2013-10-03
    * verify that mock_server_test considers it an error when
        not all members are returned

2013-10-02
    CLIENT, MOCK_CLIENT
    * change protocol so that nodeID is assigned by server (to
        avoid Douceur's Sybil Attack)
        - so first variant of Client message has token + digSig
            * without clientID in token
                - any client ID is ignored and discarded
                - which will cause digSig to be wrong
        - second version of Client message has only clientID + digSig
        - either attaches client's full token to the connection
            * this includes nodeID
    * code up the usual serialization/deserialization
        * ParseClient
        * Client.String()
        * Client.Strings()
        * Client.Run()
    * when a Client is run,
        - if it has a configuration in its lfs, it loads = does a
            ParseClient on its configuration file; this returns
            a Client with a *xn.Node field
        - otherwise it starts talking to the server (does a
            Hello/Reply to get a session key) and then sends a
            Client message without a nodeID; the nodeID returned
            is used to build its *xn.Node
    * if testing (-T option), default lfs is ./tmp/ID/lfs, where
        ID is the hex version of the server-assigned ID
    * otherwise default lfs is ./lfs
        - so there is one obvious configuration file in a subdirectory
            of the current directory

    SERVER, CLIENT/SERVER MESSAGING
    * it must be possible for a Client to create a Cluster (by name)    * DONE
        and set its size without joining it                             * DONE
        - ah: it must be possible for a Client to create a Cluster
            without a name and get its assigned name and ID back
    * equally it must be possible for a client to join a cluster        * DONE
        using its name and get its ID back
        - but if it's full the client gets a ClusterFull error msg

    * code up Registry serialization in reg/registry.go:
        - ParseRegistry()
        - String()
        - Strings()

    * code up RegServer bits in reg/server.go:
        - ParseRegServer()
        - String()
        - Strings()

    * any errors found by InHandler should be logged

2013-10-01
    * need locking for reg_cluster Members
        - checking whether client is cluster member by ID (read lock)
    * registry RegMembersByID should be dropped or used; if used
        - when members added to clusters
            * must read lock reg and check reg.RegMembersByID
            * must write lock when adding
        - but need to decide whether this is useful
            * and whether the intention is to prevent clients from
                belonging to more than one cluster (why??)
    * when this is running, drop into ../cmd/xlReg/xlReg

2013-09-30
    * xlReg 0.2.0 must have lfs, logging, load/save
    * deploy xlReg 0.2.0 on salinas:55555
2013-09-29
    * improve RegCluster.AddMember handling of dupe names
2013-09-24
    * packets.go readData should handle partial reads, looping on count
        until all bytes have been received
    * packets.go writeData should handle partial writes, looping on count
        until all bytes have gone
2013-09-20
    * several tests could obviously benefit from parallelizing:
        they run one CPU at 100% while the others are more or less idle
        - look at cluster_member_test
        - also reg_cluster_test
2013-09-13
    * URGENT FIX: ClientMsg does NOT include digsig, so server cannot   * DONE
        verify that the client knows skPriv                             * DONE
    * longer term xlReg needs to be distributed, using Paxos for
        consensus
2013-09-12
    * build and thoroughly test ../cmd/xlReg                            * DONE
    * this stays on main branch
    * deploy on test:44444 as service

    * on regBeta branch figure out how to persist the registry in       * DONE
        such a way it easily loads itself from disk after a             * DONE
        crash or reboot                                                 * DONE
    * when this is stable, merge back into main branch                  * DONE
        - and deploy on test:44444
    * document
